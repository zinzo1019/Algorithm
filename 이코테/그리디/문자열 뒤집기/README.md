# 🌀 문자열 뒤집기

## 📌 문제 설명
0과 1로 이루어진 문자열이 주어졌을 때, **연속된 숫자 그룹을 최소한으로 뒤집어 모두 같은 숫자로 만드는 최소 횟수**를 구하세요.

### 🔹 입력
- 0과 1로 이루어진 문자열이 주어집니다. (길이는 최대 100만)

### 🔹 출력
- **모든 숫자가 동일하도록 만들기 위해 필요한 최소 뒤집기 횟수**를 출력합니다.

---

## 💡 문제 해결 아이디어
1. 문자열에서 **연속된 숫자가 변경되는 순간을 찾는다**.
2. **0 그룹 개수와 1 그룹 개수를 각각 센다**.
3. **더 적은 그룹을 뒤집으면 최소 횟수**가 된다.
4. 최종적으로 `min(count0, count1)`을 출력한다.

---

## 🔍 예제

| 입력 | 출력 |
|------|------|
| `0001100` | `1` |
| `11111` | `0` |
| `0101010101` | `5` |
| `110000011` | `2` |
| `01` | `1` |
| `0000000000` | `0` |

---

## 🛠 코드 구현
```python
list = list(map(int, input()))

count0 = 0 # 연속된 0의 총 개수 ex) 0001100 -> 2
count1 = 0 # 연속된 1의 총 개수 ex) 0001100 -> 1

# 주어진 인덱스의 값이 0이면 count0을 증가시키고,
# 1이면 count1을 증가시킨다.
def incrementGroupCount(index):
    global count0, count1
    if list[index] == 0: count0 += 1
    if list[index] == 1: count1 += 1

# 첫 번째 인덱스로 그룹 초기화
incrementGroupCount(0)
for i in range(1, len(list)):
    if list[i-1] == list[i]: continue
    else: incrementGroupCount(i)

print(min(count0, count1))
```

---

## ⚡ 시간 복잡도 분석
- **O(N)**: 문자열을 한 번만 순회하며 그룹을 세므로 **선형 시간**에 해결 가능!

---

## 🎯 포인트 정리
✅ 연속된 숫자 그룹을 찾아 개수를 센다.  
✅ 0 그룹과 1 그룹 중 **더 작은 개수를 뒤집는다**.  
✅ **O(N)의 효율적인 풀이**로 대량의 데이터도 처리 가능! 🚀

---

## 🏆 한 단계 더!
- **입력이 매우 길 때도 잘 동작할까?** (최대 100만) 🧐
- **다른 방법으로도 풀 수 있을까?** (예: 슬라이딩 윈도우)
- **테스트 케이스를 다양하게 만들어 검증해보기!** 🔍

